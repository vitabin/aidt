"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_sinon = __toESM(require("sinon"));
var import_traverse = __toESM(require("traverse"));
var import_aws_sdk = __toESM(require("aws-sdk"));
var import_stream = require("stream");
var _AWS = import_aws_sdk.default;
var AWS = {
  Promise: global.Promise,
  mock,
  remock,
  restore,
  setSDK,
  setSDKInstance
};
var services = {};
async function setSDK(path) {
  _AWS = require(path);
}
function setSDKInstance(sdk) {
  _AWS = sdk;
}
function mock(service, method, replace) {
  if (!services[service]) {
    const service_to_add = {
      // Save the real constructor so we can invoke it later on.
      // Uses traverse for easy access to nested services (dot-separated)
      Constructor: (0, import_traverse.default)(_AWS).get(service.split(".")),
      methodMocks: {},
      invoked: false
    };
    services[service] = service_to_add;
    mockService(service);
  }
  const serviceObj = services[service];
  const methodName = method;
  if (!serviceObj.methodMocks[methodName]) {
    if (serviceObj !== void 0)
      serviceObj.methodMocks[methodName] = { replace };
    if (serviceObj.invoked) {
      serviceObj.clients?.forEach((client) => {
        mockServiceMethod(service, client, methodName, replace);
      });
    }
  }
  const methodMockObj = serviceObj.methodMocks[methodName];
  return methodMockObj;
}
function remock(service, method, replace) {
  if (services[service]?.methodMocks[method]) {
    restoreMethod(service, method);
    const service_obj = services[service];
    if (service_obj !== void 0) {
      service_obj.methodMocks[method] = {
        replace
      };
    }
  }
  const methodName = method;
  if (services[service]?.invoked) {
    services[service]?.clients?.forEach((client) => {
      mockServiceMethod(service, client, methodName, replace);
    });
  }
  return services[service]?.methodMocks[method];
}
function mockService(service) {
  const nestedServices = service.split(".");
  const method = nestedServices.pop();
  const object = (0, import_traverse.default)(_AWS).get(nestedServices);
  const service_obj = services[service];
  if (service_obj) {
    const serviceStub = import_sinon.default.stub(object, method).callsFake(function(...args) {
      service_obj.invoked = true;
      const client = new service_obj.Constructor(...args);
      service_obj.clients = service_obj.clients || [];
      service_obj.clients.push(client);
      for (const key in service_obj.methodMocks) {
        const methodKey = key;
        const objectMethodMock = service_obj.methodMocks[key];
        if (objectMethodMock) {
          mockServiceMethod(service, client, methodKey, objectMethodMock.replace);
        }
      }
      return client;
    });
    service_obj.stub = serviceStub;
  }
}
function wrapTestStubReplaceFn(replace) {
  if (typeof replace !== "function" || !(replace._isMockFunction || replace.isSinonProxy)) {
    return replace;
  }
  return (params, callback) => {
    let cb;
    if (callback === void 0 || !callback) {
      cb = params;
    } else {
      cb = callback;
    }
    const cbSpy = import_sinon.default.spy(cb);
    try {
      const result = replace.length === 1 ? replace(cbSpy) : replace(params, cbSpy);
      if (cbSpy.called) {
        return;
      }
      if (typeof result.then === "function") {
        result.then(
          /* istanbul ignore next */
          (val) => cb(void 0, val),
          (err) => {
            return cb(err);
          }
        );
      } else {
        cb(void 0, result);
      }
    } catch (err) {
      cb(err);
    }
  };
}
function mockServiceMethod(service, client, method, replace) {
  replace = wrapTestStubReplaceFn(replace);
  const service_obj = services[service];
  const serviceMethodMock = service_obj.methodMocks[method];
  serviceMethodMock.stub = import_sinon.default.stub(client, method).callsFake(function() {
    const args = Array.prototype.slice.call(arguments);
    let userArgs;
    let userCallback;
    if (typeof args[(args.length || 1) - 1] === "function") {
      userArgs = args.slice(0, -1);
      userCallback = args[(args.length || 1) - 1];
    } else {
      userArgs = args;
    }
    const havePromises = typeof AWS.Promise === "function";
    let promise;
    let resolve;
    let reject;
    let storedResult;
    const tryResolveFromStored = function() {
      if (storedResult && promise) {
        if (typeof storedResult.then === "function") {
          storedResult.then(resolve, reject);
        } else if (storedResult.reject) {
          reject(storedResult.reject);
        } else {
          resolve(storedResult.resolve);
        }
      }
    };
    const callback = function(err, data) {
      if (!storedResult) {
        if (err) {
          storedResult = { reject: err };
        } else {
          storedResult = { resolve: data };
        }
      }
      if (userCallback) {
        userCallback(err, data);
      }
      tryResolveFromStored();
    };
    const request = {
      promise: havePromises ? function() {
        if (!promise) {
          promise = new AWS.Promise(function(resolve_, reject_) {
            resolve = resolve_;
            reject = reject_;
          });
        }
        tryResolveFromStored();
        return promise;
      } : void 0,
      createReadStream: function() {
        if (storedResult instanceof import_stream.Readable) {
          return storedResult;
        }
        if (replace instanceof import_stream.Readable) {
          return replace;
        } else {
          const stream = new import_stream.Readable();
          stream._read = function() {
            if (typeof replace === "string" || Buffer.isBuffer(replace)) {
              this.push(replace);
            }
            this.push(null);
          };
          return stream;
        }
      },
      on: function(eventName, callback2) {
        return this;
      },
      send: function(callback2) {
        callback2(storedResult.reject, storedResult.resolve);
      },
      abort: function() {
      }
    };
    const _client = client;
    const config = _client.config || _client.options || _AWS.config;
    if (config.paramValidation) {
      try {
        const inputRules = (_client.api && _client.api.operations[method] || _client[method] || {}).input;
        if (inputRules) {
          const params = userArgs[(userArgs.length || 1) - 1];
          new _AWS.ParamValidator((_client.config || _AWS.config).paramValidation).validate(inputRules, params);
        }
      } catch (e) {
        callback(e, null);
        return request;
      }
    }
    if (replace instanceof Function) {
      const concatUserArgs = userArgs.concat([callback]);
      const result = replace.apply(replace, concatUserArgs);
      if (storedResult === void 0 && result != null && (typeof result === "object" && result.then instanceof Function || result instanceof import_stream.Readable)) {
        storedResult = result;
      }
    } else {
      callback(null, replace);
    }
    return request;
  });
}
function restore(service, method) {
  if (!service) {
    restoreAllServices();
  } else {
    if (method) {
      restoreMethod(service, method);
    } else {
      restoreService(service);
    }
  }
}
function restoreAllServices() {
  for (let serviceKey in services) {
    const service = serviceKey;
    restoreService(service);
  }
}
function restoreService(service) {
  if (services[service]) {
    restoreAllMethods(service);
    const serviceObj = services[service];
    if (serviceObj) {
      const stubFun = services[service]?.stub;
      if (stubFun) {
        stubFun.restore();
      }
    }
    delete services[service];
  } else {
    console.log("Service " + service + " was never instantiated yet you try to restore it.");
  }
}
function restoreAllMethods(service) {
  for (const method in services[service]?.methodMocks) {
    const methodName = method;
    restoreMethod(service, methodName);
  }
}
function restoreMethod(service, method) {
  const methodName = method;
  const serviceObj = services[service];
  if (!serviceObj) {
    console.log("Method " + service + " was never instantiated yet you try to restore it.");
    return;
  }
  const serviceClients = services[service]?.clients;
  if (serviceClients) {
    serviceClients.forEach((client) => {
      const mockedClientMethod = client[methodName];
      if (mockedClientMethod && typeof mockedClientMethod.restore === "function") {
        mockedClientMethod.restore();
      }
    });
  }
  delete services[service]?.methodMocks[methodName];
}
(function() {
  const setPromisesDependency = _AWS.config.setPromisesDependency;
  if (typeof setPromisesDependency === "function") {
    AWS.Promise = global.Promise;
    _AWS.config.setPromisesDependency = function(p) {
      AWS.Promise = p;
      return setPromisesDependency(p);
    };
  }
})();
module.exports = AWS;
