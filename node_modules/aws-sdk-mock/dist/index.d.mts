import AWS_SDK from 'aws-sdk';
import { AWSError, Request } from 'aws-sdk/lib/core.js';
import AWS$1 from 'aws-sdk/clients/all';
import { SinonStub } from 'sinon';

type ClientName = keyof typeof AWS$1;
type Client<C extends ClientName> = InstanceType<(typeof AWS$1)[C]>;
type ExtractMethod<T extends {}> = {
    [K in keyof T]: T[K] extends (...args: any[]) => any ? T[K] : never;
};
type MethodName<C extends ClientName> = keyof ExtractMethod<Client<C>>;
type Method<C extends ClientName, M extends MethodName<C>> = ExtractMethod<Client<C>>[M];
type AWSRequest<C extends ClientName, M extends MethodName<C>> = Method<C, M> extends AWSMethod<infer P, any> ? P : never;
type AWSCallback<C extends ClientName, M extends MethodName<C>> = Method<C, M> extends AWSMethod<any, infer D> ? {
    (err: undefined, data: D): void;
    (err: AWSError, data?: undefined): void;
} : any;
type ReplaceFn<C extends ClientName, M extends MethodName<C>> = ((params: AWSRequest<C, M>, options: any, callback: AWSCallback<C, M>) => any) | string | object;
type Callback<D> = (err: AWSError | undefined, data: D) => void;
interface AWSMethod<P, D> {
    (params: P, callback?: Callback<D>): Request<D, AWSError>;
    (callback?: Callback<D>): Request<D, AWSError>;
}
type MaybeSoninProxy = {
    _isMockFunction: boolean;
    isSinonProxy: boolean;
};
type Replace<C extends ClientName, M extends MethodName<C>> = {
    replace: ReplaceFn<C, M>;
    stub?: SinonStub<any, any> & Partial<MaybeSoninProxy>;
};
/**
 * You can find in the commented block below the first implementation of nested types.
 * They *don't work* because it's impossible. The `aws-sdk` library exports clients and each "method" is a type, not a value.
 * Therefore, it's impossible to get these as string literals.
 * See our question on Stack Overflow answered in https://stackoverflow.com/questions/77413867/how-to-create-a-type-that-yields-a-dot-notation-of-nested-class-properties-as-st.
 *
 * Because we still want the Typescript compiler to show the original clients as suggestions
 * when using an IDE, we're using `OtherString` as a branded primitive type.
 * It allows us the compiler to not reduce the `ClientName` string literals to `string`
 * but still accept any string, all the while suggesting the string literals from `ClientName`.
 *
 * For more detailed explanation on this, check https://stackoverflow.com/questions/67757457/make-typescript-show-type-hint-for-string-literal-when-union-with-string-primiti.
 * For a simple explanation, check https://github.com/microsoft/TypeScript/issues/29729#issuecomment-567871939.
 */
type OtherString = string & {};
type NestedClientName = ClientName | OtherString;
type NestedMethodName = OtherString;

type AWS_MOCK = {
    mock: typeof mock;
    remock: typeof remock;
    restore: typeof restore;
    setSDK: typeof setSDK;
    setSDKInstance: typeof setSDKInstance;
    Promise: Awaited<Promise<any>>;
};
declare const AWS: AWS_MOCK;
/**
 * Explicitly sets the `aws-sdk` to be mocked.
 * @param path path for the `aws-sdk`.
 */
declare function setSDK(path: string): Promise<void>;
/**
 * Explicitly sets the `aws-sdk` instance to be used.
 * @param sdk the `aws-sdk` instance.
 */
declare function setSDKInstance(sdk: typeof AWS_SDK): void;
/**
 * Stubs the service and registers the method that needs to be mocked.
 *
 * @param service AWS service to mock (e.g. DynamoDB).
 * @param method method on AWS service to mock (e.g. `putItem` for DynamoDB).
 * @param replace string or function to replace the method.
 */
declare function mock<C extends ClientName>(service: NestedClientName, method: NestedMethodName, replace: ReplaceFn<C, MethodName<ClientName>>): Replace<ClientName, MethodName<ClientName>>;
/**
 * Stubs the service and registers the method that needs to be re-mocked.
 *
 * @param service AWS service to mock (e.g. DynamoDB).
 * @param method method on AWS service to mock (e.g. `putItem` for DynamoDB).
 * @param replace string or function to replace the method.
 */
declare function remock<C extends ClientName>(service: NestedClientName, method: NestedMethodName, replace: ReplaceFn<C, MethodName<ClientName>>): void;
/**
 * Restores the mocks for just one method on a service, the entire service, or all mocks.
 *
 * When no parameters are passed, everything will be reset.
 * When only the service is passed, that specific service will be reset.
 * When a service and method are passed, only that method will be reset.
 *
 * @param service service to be restored.
 * @param method method of the service to be restored.
 */
declare function restore<C extends ClientName>(service?: NestedClientName, method?: NestedMethodName): void;

export { AWS as default };
