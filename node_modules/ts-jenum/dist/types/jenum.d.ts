/**
 * Decorator for Enum.
 * @param {string} idPropertyName - property name to find enum value by property value. Usage in valueOf method
 * @return constructor of enum type
 */
export declare function Enum<T = any>(idPropertyName?: keyof T): <T_1 extends Function & EnumClass>(target: T_1) => T_1;
/** Key->Value type */
declare type EnumMap = {
    [key: string]: Enumerable;
};
/** Type for Meta-Data of Enum */
declare type EnumClass = {
    __store__: EnumStore;
};
/** Store Type. Keep meta data for enum */
declare type EnumStore = {
    name: string;
    enumMap: EnumMap;
    enumMapByName: EnumMap;
    enumValues: Enumerable[];
    idPropertyName?: any;
};
/** Enum Item Type */
declare type EnumItemType = {
    __enumName__: string;
};
export declare type SearchPredicate<T> = (value: T, index?: number, obj?: ReadonlyArray<T>) => boolean;
/** Interface for IDE: autocomplete syntax and keywords */
export interface IStaticEnum<T> extends EnumClass {
    new (): {
        enumName: string;
    };
    /** @returns all elements of enum */
    values(): ReadonlyArray<T>;
    /**
     * Get all names of enum.
     * It's shortcut for 'values().map(value => value.enumName)'
     * @returns all names of enum */
    keys(): string[];
    /**
     * Lookup enum item by id
     * @param id value for lookup or throw error
     * @throws enum item not found
     */
    valueOf(id: string | number): T;
    /**
     * Lookup enum item by enum name
     * @param name enum name
     * @return item by enum name or throw error
     * @throws enum item not found
     */
    valueByName(name: string): T;
    /**
     * Lookup enum item by id or search by predicate
     * @param idOrPredicate id or predicate
     * @return item ot `null`
     */
    find(idOrPredicate: string | number | SearchPredicate<T>): T | null;
    /**
     * Filter enum items by predicate
     * @param predicate function to filtering
     * @return items ot `[]`
     */
    filter(predicate: SearchPredicate<T>): ReadonlyArray<T>;
}
/** Base class for enum type */
declare class Enumerable implements EnumItemType {
    static readonly __store__: EnumStore;
    __enumName__: string;
    constructor();
    /**
     * Get all elements of enum
     * @return all elements of enum
     */
    static values(): ReadonlyArray<any>;
    /**
     * Get all enum names
     * @return all enum names
     */
    static keys(): string[];
    /**
     * Lookup enum item by id
     * @param {string | number} id - value for lookup
     * @return enum item by id
     */
    static valueOf(id: string | number): any;
    /**
     * Lookup enum item by enum name
     * @param name enum name
     * @return item by enum name
     */
    static valueByName(name: string): any;
    static find(idOrPredicate: string | number | SearchPredicate<any>): any | null;
    static filter(predicate: SearchPredicate<any>): ReadonlyArray<any>;
    /** Get enum name */
    readonly enumName: string;
    /** Get enum id value or enum name */
    toString(): string;
    private readonly topClass;
}
/** 'Casting' method to make correct Enum Type */
export declare function EnumType<T>(): IStaticEnum<T>;
/** Get Names Of Enums */
export declare type EnumConstNames<T extends {
    prototype: K;
}, K = T["prototype"]> = Exclude<GetNames<T, K>, "prototype">;
declare type GetNames<FromType, KeepType = any, Include = true> = {
    [K in keyof FromType]: FromType[K] extends KeepType ? Include extends true ? K : never : Include extends true ? never : K;
}[keyof FromType];
/**
 * Powerful tool to comfortable work with plain json struct like enum
 */
export declare class EnumTools {
    /**
     * Get all properties key as string
     * @param struct that to be scanned
     * @returns all properties name as string
     */
    static keys<T>(struct: T): string[];
    /**
     * Get all values
     * @param struct that to be scanned
     * @returns all properties name as string
     */
    static values<T>(struct: T): Array<T[keyof T]>;
    /**
     * Reverse key and value
     * @param struct that to be scanned
     * @returns reversed struct
     */
    static reverse<T extends {
        [key: string]: string | number;
    }>(struct: T): {
        [key: string]: string;
    };
    /**
     * Get array of pair with `{key: string, value: string | number}` struct
     * @param struct that to be scanned
     * @returns array of pair with `{key: string, value: string | number}` struct
     */
    static pairs<T extends {
        [key: string]: string | number;
    }>(struct: T): Array<{
        key: string;
        value: string | number;
    }>;
    /**
     * Creating class that extends from EnumType and has all static functionality
     * @param struct that to be scanned
     * @returns class that extends from EnumType and has all static functionality
     */
    static toClass<T extends {
        [key: string]: string | number;
    }>(struct: T): {
        new (key: string, value: string | number): {
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        };
        /** @returns all elements of enum */
        values(): ReadonlyArray<{
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        }>;
        /**
         * Get all names of enum.
         * It's shortcut for 'values().map(value => value.enumName)'
         * @returns all names of enum */
        keys(): string[];
        /**
         * Lookup enum item by id
         * @param id value for lookup or throw error
         * @throws enum item not found
         */
        valueOf(id: string | number): {
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        };
        /**
         * Lookup enum item by enum name
         * @param name enum name
         * @return item by enum name or throw error
         * @throws enum item not found
         */
        valueByName(name: string): {
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        };
        /**
         * Lookup enum item by id or search by predicate
         * @param idOrPredicate id or predicate
         * @return item ot `null`
         */
        find(idOrPredicate: string | number | SearchPredicate<{
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        }>): {
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        } | null;
        /**
         * Filter enum items by predicate
         * @param predicate function to filtering
         * @return items ot `[]`
         */
        filter(predicate: SearchPredicate<{
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        }>): ReadonlyArray<{
            readonly key: string;
            readonly value: string | number;
            enumName: string;
        }>;
        __store__: EnumStore;
    } & Record<keyof T, {
        readonly key: string;
        readonly value: string | number;
        enumName: string;
    }>;
}
export {};
//# sourceMappingURL=jenum.d.ts.map