"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Decorator for Enum.
 * @param {string} idPropertyName - property name to find enum value by property value. Usage in valueOf method
 * @return constructor of enum type
 */
function Enum(idPropertyName) {
    // tslint:disable-next-line
    return function (target) {
        var store = {
            name: target.prototype.constructor.name,
            enumMap: {},
            enumMapByName: {},
            enumValues: [],
            idPropertyName: idPropertyName
        };
        // Lookup static fields
        for (var _i = 0, _a = Object.keys(target); _i < _a.length; _i++) {
            var fieldName = _a[_i];
            var value = target[fieldName];
            // Check static field: to be instance of enum type
            if (value instanceof target) {
                var enumItem = value;
                var id = fieldName;
                if (idPropertyName) {
                    id = value[idPropertyName];
                    if (typeof id !== "string" && typeof id !== "number") {
                        var enumName = store.name;
                        throw new Error("The value of the " + idPropertyName + " property in the enumeration element " + enumName + "." + fieldName + " is not a string or a number: " + id);
                    }
                }
                if (store.enumMap[id]) {
                    var enumName = store.name;
                    throw new Error("An element with the identifier " + id + ": " + enumName + "." + store.enumMap[id].enumName + " already exists in the enumeration " + enumName);
                }
                store.enumMap[id] = enumItem;
                store.enumMapByName[fieldName] = enumItem;
                store.enumValues.push(enumItem);
                enumItem.__enumName__ = fieldName;
                Object.freeze(enumItem);
            }
        }
        target.__store__ = store;
        Object.freeze(target.__store__);
        Object.freeze(target);
        return target;
    };
}
exports.Enum = Enum;
/** Base class for enum type */
var Enumerable = /** @class */ (function () {
    // tslint:enable:variable-name
    function Enumerable() {
        // Initialize inside @Enum decorator
        this.__enumName__ = "";
    }
    /**
     * Get all elements of enum
     * @return all elements of enum
     */
    Enumerable.values = function () {
        return this.__store__.enumValues;
    };
    /**
     * Get all enum names
     * @return all enum names
     */
    Enumerable.keys = function () {
        return this.values().map(function (value) { return value.enumName; });
    };
    /**
     * Lookup enum item by id
     * @param {string | number} id - value for lookup
     * @return enum item by id
     */
    Enumerable.valueOf = function (id) {
        var value = this.__store__.enumMap[id];
        if (!value) {
            throw new Error("The element with " + id + " identifier does not exist in the $ {clazz.name} enumeration");
        }
        return value;
    };
    /**
     * Lookup enum item by enum name
     * @param name enum name
     * @return item by enum name
     */
    Enumerable.valueByName = function (name) {
        var value = this.__store__.enumMapByName[name];
        if (!value) {
            throw new Error("The element with " + name + " name does not exist in the " + this.__store__.name + " enumeration");
        }
        return value;
    };
    Enumerable.find = function (idOrPredicate) {
        if (typeof idOrPredicate === "number" || typeof idOrPredicate === "string") {
            return this.__store__.enumMap[idOrPredicate] || null;
        }
        return this.values().find(idOrPredicate) || null;
    };
    Enumerable.filter = function (predicate) {
        return this.values().filter(predicate);
    };
    Object.defineProperty(Enumerable.prototype, "enumName", {
        /** Get enum name */
        get: function () {
            return this.__enumName__;
        },
        enumerable: true,
        configurable: true
    });
    /** Get enum id value or enum name */
    Enumerable.prototype.toString = function () {
        var clazz = this.topClass;
        if (clazz.__store__.idPropertyName) {
            var self = this;
            return self[clazz.__store__.idPropertyName];
        }
        return this.enumName;
    };
    Object.defineProperty(Enumerable.prototype, "topClass", {
        get: function () {
            return this.constructor;
        },
        enumerable: true,
        configurable: true
    });
    // tslint:disable:variable-name
    // stub. need for type safety
    Enumerable.__store__ = {};
    return Enumerable;
}());
/** 'Casting' method to make correct Enum Type */
function EnumType() {
    return Enumerable;
}
exports.EnumType = EnumType;
/**
 * Powerful tool to comfortable work with plain json struct like enum
 */
var EnumTools = /** @class */ (function () {
    function EnumTools() {
    }
    /**
     * Get all properties key as string
     * @param struct that to be scanned
     * @returns all properties name as string
     */
    EnumTools.keys = function (struct) {
        return Object.keys(struct);
    };
    /**
     * Get all values
     * @param struct that to be scanned
     * @returns all properties name as string
     */
    EnumTools.values = function (struct) {
        return Object.keys(struct).map(function (key) { return struct[key]; });
    };
    /**
     * Reverse key and value
     * @param struct that to be scanned
     * @returns reversed struct
     */
    EnumTools.reverse = function (struct) {
        var reversedStruct = {};
        for (var key in struct) {
            reversedStruct[struct[key]] = key;
        }
        return reversedStruct;
    };
    /**
     * Get array of pair with `{key: string, value: string | number}` struct
     * @param struct that to be scanned
     * @returns array of pair with `{key: string, value: string | number}` struct
     */
    EnumTools.pairs = function (struct) {
        var pairs = [];
        for (var key in struct) {
            pairs.push({
                key: key,
                value: struct[key]
            });
        }
        return pairs;
    };
    /**
     * Creating class that extends from EnumType and has all static functionality
     * @param struct that to be scanned
     * @returns class that extends from EnumType and has all static functionality
     */
    EnumTools.toClass = function (struct) {
        // declare class of enum
        var KeyValueEnum = /** @class */ (function (_super) {
            __extends(InnerEnum, _super);
            function InnerEnum(key, value) {
                var _this = _super.call(this) || this;
                _this.key = key;
                _this.value = value;
                return _this;
            }
            return InnerEnum;
        }(EnumType()));
        // Dirty hack. Needs to be getting correct type of KeyValueEnum instance
        var IgnoredEnum = new KeyValueEnum("", "");
        // add static constant
        for (var _i = 0, _a = Object.keys(struct); _i < _a.length; _i++) {
            var key = _a[_i];
            KeyValueEnum[key] = new KeyValueEnum(key, struct[key]);
        }
        // wrap by Enum decorator
        var WrappedEnum = Enum("key")(KeyValueEnum);
        // complete correct type
        return WrappedEnum;
    };
    return EnumTools;
}());
exports.EnumTools = EnumTools;
//# sourceMappingURL=jenum.js.map