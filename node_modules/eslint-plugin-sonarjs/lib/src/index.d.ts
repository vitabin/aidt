import type { TSESLint } from '@typescript-eslint/utils';
import type { FlatConfig } from '@typescript-eslint/utils/ts-eslint';
export declare const rules: {
    'cognitive-complexity': TSESLint.RuleModule<string, (number | "sonar-runtime" | "metric")[], TSESLint.RuleListener>;
    'elseif-without-else': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'max-switch-cases': TSESLint.RuleModule<string, [number], TSESLint.RuleListener>;
    'no-all-duplicated-branches': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-collapsible-if': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-collection-size-mischeck': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-duplicate-string': TSESLint.RuleModule<string, [{
        threshold?: number | undefined;
        ignoreStrings?: string | undefined;
    } | undefined, "sonar-runtime"] | [{
        threshold?: number | undefined;
        ignoreStrings?: string | undefined;
    } | undefined], TSESLint.RuleListener>;
    'no-duplicated-branches': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-element-overwrite': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-empty-collection': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-extra-arguments': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-gratuitous-expressions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-identical-conditions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-identical-expressions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-identical-functions': TSESLint.RuleModule<string, (number | "sonar-runtime")[], TSESLint.RuleListener>;
    'no-ignored-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-inverted-boolean-check': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-nested-switch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-nested-template-literals': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-one-iteration-loop': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-redundant-boolean': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-redundant-jump': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-same-line-conditional': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-small-switch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-unused-collection': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-use-of-empty-return-value': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'no-useless-catch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'non-existent-operator': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'prefer-immediate-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'prefer-object-literal': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'prefer-single-boolean-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    'prefer-while': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
};
export declare const configs: {
    recommended: FlatConfig.Config;
    'recommended-legacy': TSESLint.ClassicConfig.Config;
};
export declare const meta: {
    name: string;
    version: string;
};
declare const _default: {
    rules: {
        'cognitive-complexity': TSESLint.RuleModule<string, (number | "sonar-runtime" | "metric")[], TSESLint.RuleListener>;
        'elseif-without-else': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'max-switch-cases': TSESLint.RuleModule<string, [number], TSESLint.RuleListener>;
        'no-all-duplicated-branches': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-collapsible-if': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-collection-size-mischeck': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-duplicate-string': TSESLint.RuleModule<string, [{
            threshold?: number | undefined;
            ignoreStrings?: string | undefined;
        } | undefined, "sonar-runtime"] | [{
            threshold?: number | undefined;
            ignoreStrings?: string | undefined;
        } | undefined], TSESLint.RuleListener>;
        'no-duplicated-branches': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-element-overwrite': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-empty-collection': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-extra-arguments': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-gratuitous-expressions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-identical-conditions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-identical-expressions': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-identical-functions': TSESLint.RuleModule<string, (number | "sonar-runtime")[], TSESLint.RuleListener>;
        'no-ignored-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-inverted-boolean-check': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-nested-switch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-nested-template-literals': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-one-iteration-loop': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-redundant-boolean': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-redundant-jump': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-same-line-conditional': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-small-switch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-unused-collection': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-use-of-empty-return-value': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'no-useless-catch': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'non-existent-operator': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'prefer-immediate-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'prefer-object-literal': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'prefer-single-boolean-return': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
        'prefer-while': TSESLint.RuleModule<string, string[], TSESLint.RuleListener>;
    };
    configs: {
        recommended: FlatConfig.Config;
        'recommended-legacy': TSESLint.ClassicConfig.Config;
    };
    meta: {
        name: string;
        version: string;
    };
};
export default _default;
